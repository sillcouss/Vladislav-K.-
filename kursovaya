# МИНИСТЕРСТВО ОБРАЗОВАНИЯ, НАУКИ И МОЛОДЕЖНОЙ ПОЛИТИКИ РЕСПУБЛИКИ КОМИ

Государственное профессиональное образовательное учреждение "Сыктывкарский политехнический техникум"

## Курсовая работа

Тема: БД районной поликлиники. Подсистема «Работа с пациентами».

 Срок представления работы к защите: 15 ноября 2024 года. 

Профессия/специальность

09.02.07 "Информационные системы и программирование" 

Выполнил

Кашин Владислав Игоревич

Дневная, 4 курс, 414 группа

"11" ноября 2024г.

Руководитель

Пунгин И.В.

__________________________________________
"11" ноября 2024г.

Сыктывкар 2024


# Задание на курсовую работу  
**по МДК 11.01 "Технология разработки и защиты баз данных"**  
**Специальность:** 09.02.07 "Информационные системы и программирование"  

**Тема курсовой работы:** БД районной поликлиники. Подсистема «Работа с пациентами». 

**Срок представления работы к защите:** 15 ноября 2024 года.  

## Перечень подлежащих разработке вопросов:  

1. **Анализ предметной области. Постановка задачи.**  
   1.1. Описание предметной области и функции решаемых задач.  
   1.2. Перечень входных данных.  
   1.3. Перечень выходных данных.  
   1.4. Ограничения предметной области (если таковые имеются).  
   1.5. Взаимодействие с другими программами.  

2. **Инфологическая (концептуальная) модель базы данных.**  
   2.1. Выделение информационных объектов.  
   2.2. Определение атрибутов объектов.  
   2.3. Определение отношений и мощности отношений между объектами.  
   2.4. Построение концептуальной модели.  

3. **Логическая структура БД.**  

4. **Физическая структура базы данных.**  

5. **Реализация проекта в среде конкретной СУБД.**  
   5.1. Создание таблиц.  
   5.2. Создание запросов.  
   5.3. Разработка интерфейса.  
   5.4. Назначение прав доступа.  
   5.5. Создание индексов.  
   5.6. Разработка стратегии резервного копирования базы данных.  

---

**Руководитель работы**  
__________________  
И. В. Пунгин  

**Задание принял к исполнению**  
_______________________________  
В. И. Кашин  


# Содержание курсовой работы

1. **Титульный лист**  
2. **Отзыв руководителя** *(по желанию)*  
3. **Задание на курсовую работу**  
4. **Содержание** *(этот раздел)*  
5. **Введение**  
   - 5.1. Актуальность темы  
   - 5.2. Цель работы  
   - 5.3. Задачи исследования  

6. **Основная часть**  
   6.1. Анализ предметной области. Постановка задачи  
     - 6.1.1. Описание предметной области и функции решаемых задач  
     - 6.1.2. Перечень входных данных  
     - 6.1.3. Перечень выходных данных  
     - 6.1.4. Ограничения предметной области  
     - 6.1.5. Взаимодействие с другими программами  

   6.2. Инфологическая модель базы данных  
     - 6.2.1. Выделение информационных объектов  
     - 6.2.2. Определение атрибутов объектов  
     - 6.2.3. Определение отношений между объектами  
     - 6.2.4. Построение концептуальной модели (ER-диаграмма)  

   6.3. Логическая структура БД  
     - Нормализация таблиц  
     - Схема отношений  

   6.4. Физическая структура базы данных  
     - Выбор СУБД  
     - Скрипты создания  

   6.5. Реализация в СУБД  
     - 6.5.1. Создание таблиц  
     - 6.5.2. Создание запросов  
     - 6.5.3. Разработка интерфейса  
     - 6.5.4. Назначение прав доступа  
     - 6.5.5. Создание индексов  
     - 6.5.6. Стратегия резервного копирования  

7. **Заключение**  
   - Итоги работы  
   - Практическая значимость  

8. **Список использованных источников**  
   - Книги и нормативные документы  
   - Онлайн-ресурсы  

9. **Приложения**  
   - Приложение А. SQL-скрипты  
   - Приложение Б. Руководство пользователя (по ГОСТ 19.505-79)  
   - Приложение В. Руководство программиста (по ГОСТ 19.503-79)  


# Введение

## Актуальность темы

В современных условиях цифровизации здравоохранения автоматизация работы медицинских учреждений становится критически важной задачей. Районные поликлиники ежедневно обрабатывают значительные объемы данных о пациентах, что при ручном учете приводит к:

- Ошибкам в ведении медицинской документации
- Дублированию информации
- Затратам времени на поиск и обработку данных
- Сложностям в формировании отчетности

Разработка специализированной подсистемы "Работа с пациентами" для базы данных поликлиники позволяет решить эти проблемы, обеспечив:

1. Централизованное хранение информации
2. Быстрый доступ к медицинским картам
3. Автоматизацию процессов записи на прием
4. Соблюдение требований законодательства о защите персональных данных

## Цель работы

Разработка и реализация подсистемы учета пациентов для базы данных районной поликлиники на основе СУБД PostgreSQL, включающей:

- Моделирование структуры данных
- Создание эффективных механизмов хранения и обработки информации
- Обеспечение безопасности и целостности данных

## Задачи исследования

1. Провести анализ предметной области и сформулировать требования к системе
2. Разработать концептуальную модель данных (ER-диаграмма)
3. Спроектировать логическую и физическую структуру БД
4. Реализовать базу данных в PostgreSQL:
   - Создать таблицы и связи
   - Разработать основные SQL-запросы
   - Оптимизировать производительность
5. Обеспечить защиту данных:
   - Настроить права доступа
   - Реализовать стратегию резервного копирования
6. Подготовить документацию согласно требованиям ГОСТ

Работа выполняется с учетом современных стандартов проектирования баз данных и нормативных требований к медицинским информационным системам (ФЗ-152 "О персональных данных", ГОСТ Р 52633.5-2011).


# 1. Описание предметной области и функции решаемых задач

В современном мире информационные технологии играют ключевую роль в оптимизации работы медицинских учреждений, и районная поликлиника не является исключением. Подсистема «Работа с пациентами», являющаяся важнейшим компонентом базы данных (БД) районной поликлиники, предназначена для комплексной автоматизации процессов учета, хранения, обработки и анализа информации, связанной с пациентами, их обращениями за медицинской помощью, ведением электронных медицинских карт, а также взаимодействием между различными структурными подразделениями медицинского учреждения.

## 1.1. Основные функции подсистемы

Рассматриваемая подсистема выполняет широкий спектр функций, которые можно условно разделить на несколько ключевых направлений:

### Учет и регистрация пациентов

- Первичная регистрация новых пациентов при их первом обращении в поликлинику
- Ведение актуальных персональных данных (ФИО, дата рождения, пол, адрес проживания и регистрации)
- Управление контактной информацией (номера телефонов, электронная почта, альтернативные способы связи)
- Учет документов (полис ОМС, паспортные данные, СНИЛС и другие идентификаторы)
- Поддержка истории изменений персональных данных

### Ведение электронных медицинских карт

- Фиксация полной истории обращений пациента в медицинское учреждение
- Регистрация первичных жалоб и симптомов при каждом посещении
- Ведение анамнеза (истории болезней, хронических заболеваний, аллергических реакций)
- Учет результатов осмотров и диагностических мероприятий
- Фиксация назначений (медикаментозная терапия, процедуры, рекомендации)
- Отслеживание выполнения назначений и их эффективности

### Организация приема пациентов

- Управление расписанием врачей различных специальностей
- Запись пациентов на прием с учетом специализации врача и графика работы
- Возможность отмены и переноса записей с уведомлением всех заинтересованных сторон
- Контроль посещаемости и учет неявок на прием
- Поддержка системы электронной очереди

### Формирование отчетности и аналитика

- Генерация статистических отчетов по различным параметрам
- Анализ заболеваемости среди различных групп населения
- Контроль нагрузки на медицинский персонал
- Мониторинг эффективности работы поликлиники

### Интеграция с другими подсистемами

- Взаимодействие с модулем учета медицинского персонала
- Обмен данными с подсистемой управления расписанием
- Интеграция с лабораторным модулем
- Связь с аптечным блоком системы

## 1.2. Преимущества автоматизации

Внедрение данной подсистемы предоставляет медицинскому учреждению значительные преимущества:

- Существенное сокращение времени на поиск и обработку информации о пациентах
- Минимизация ошибок, связанных с человеческим фактором при ведении документации
- Упрощение процесса записи на прием для пациентов
- Возможность быстрого доступа к полной медицинской истории пациента
- Снижение затрат на бумажный документооборот
- Улучшение качества медицинского обслуживания за счет наличия полной информации о пациенте
- Возможность проведения глубокого анализа данных для нужд управления учреждением

## 1.3. Перечень входных данных

Для обеспечения полноценного функционирования подсистемы «Работа с пациентами» требуется обработка значительного объема входных данных, которые можно классифицировать по нескольким категориям.

### 1.3.1. Персональные данные пациентов

#### Демографическая информация:

- Полное ФИО пациента (с возможностью указания девичьей фамилии)
- Точная дата рождения (с расчетом возраста)
- Пол (с возможностью указания биологического и социального пола)
- Гражданство и национальность (для статистического учета)

#### Контактные данные:

- Адрес постоянной регистрации (с указанием индекса)
- Адрес фактического проживания (если отличается от регистрации)
- Основной контактный телефон (с возможностью указания нескольких номеров)
- Дополнительные средства связи (электронная почта, мессенджеры)
- Контактные данные доверенных лиц (для экстренных случаев)

#### Документальная информация:

- Данные полиса ОМС (номер, срок действия, страховая компания)
- Паспортные данные (серия, номер, дата выдачи, орган выдавший)
- Данные СНИЛС (для интеграции с государственными системами)
- Документы, подтверждающие льготы (при наличии)

### 1.3.2. Медицинская информация

#### Данные о здоровье:

- Группа крови и резус-фактор
- Наличие хронических заболеваний
- Учетные группы (инвалидность, диспансерное наблюдение)
- Аллергические реакции и непереносимость лекарств

#### История обращений:

- Даты и причины всех посещений поликлиники
- Специалисты, к которым обращался пациент
- Жалобы и симптомы при каждом обращении
- Результаты осмотров и заключения врачей

#### Диагностические данные:

- Поставленные диагнозы (по МКБ-10)
- Результаты лабораторных исследований
- Данные инструментальных обследований
- Заключения консультантов и специалистов

#### Лечебные мероприятия:

- Назначенные лекарственные препараты
- Физиотерапевтические процедуры
- Рекомендации по образу жизни
- План дальнейшего наблюдения

### 1.3.3. Организационные данные

#### Информация о приемах:

- Расписание работы специалистов
- График приема каждого врача
- Загруженность кабинетов
- Система записи на прием

#### Ресурсные данные:

- Информация о медицинском персонале
- Данные о кабинетах и оборудовании
- Учет рабочего времени специалистов

### 1.3.4. Внешние данные

#### Интеграционные данные:

- Информация из регистратуры
- Данные из лабораторного модуля
- Сведения из аптечной системы
- Обмен с внешними медицинскими учреждениями

#### Нормативно-справочная информация:

- Классификаторы (МКБ, номенклатура услуг)
- Нормативные документы и стандарты
- Шаблоны документов и форм

## 1.4. Перечень выходных данных

Подсистема «Работа с пациентами» генерирует широкий спектр выходных данных, которые используются различными категориями пользователей системы.

### 1.4.1. Оперативные данные

#### Справочная информация:

- Полные данные о пациенте (поиск по различным критериям)
- История обращений (хронологический список посещений)
- Актуальные назначения (текущее лечение и рекомендации)
- График предстоящих визитов (запланированные приемы)

#### Рабочие документы:

- Талон на прием (электронный и печатный вариант)
- Направления на исследования и консультации
- Выписки из медицинской карты
- Справки и заключения

#### Уведомления:

- Напоминания о записи на прием
- Оповещения о готовности результатов
- Уведомления о необходимости повторного визита

### 1.4.2. Аналитические отчеты

#### Статистические отчеты:

- Количество обращений по периодам (день, неделя, месяц)
- Распределение пациентов по возрасту и полу
- Структура заболеваемости (по диагнозам, специализациям)
- Динамика показателей за различные периоды

#### Оперативные отчеты:

- Загруженность специалистов
- Коэффициент посещаемости
- Количество неявок на прием
- Эффективность работы подразделений

#### Специализированные отчеты:

- Анализ выполнения стандартов оказания помощи
- Отчеты для страховых компаний
- Данные для органов здравоохранения
- Информация для научных исследований

### 1.4.3. Интеграционные данные

#### Данные для других подсистем:

- Информация для модуля расписания
- Направления в лабораторию
- Рецепты для аптеки
- Данные для бухгалтерии

#### Внешний обмен:

- Выгрузки для ЕГИСЗ
- Отчеты для страховых организаций
- Обмен с другими ЛПУ
- Данные для портала госуслуг

## 1.5. Ограничения предметной области

Реализация подсистемы «Работа с пациентами» осуществляется с учетом ряда существенных ограничений, которые необходимо учитывать при проектировании и эксплуатации системы.

### 1.5.1. Нормативные ограничения

#### Правовые требования:

- Строгое соблюдение Федерального закона №152-ФЗ «О персональных данных»
- Выполнение требований приказа Минздрава №103н о порядке ведения меддокументации
- Соответствие отраслевым стандартам и регламентам

#### Этические нормы:

- Гарантия соблюдения врачебной тайны
- Ограничение доступа к конфиденциальной информации
- Контроль за использованием данных

### 1.5.2. Технические ограничения

#### Системные требования:

- Ограничения по объему хранимых данных
- Требования к производительности при пиковых нагрузках
- Необходимость резервного копирования

#### Интеграционные аспекты:

- Совместимость с существующими системами
- Поддержка стандартных форматов обмена
- Обеспечение бесперебойной работы

### 1.5.3. Организационные ограничения

#### Пользовательские аспекты:

- Разграничение прав доступа для разных ролей
- Обязательность ведения журналов изменений
- Ограничения на удаление информации

#### Эксплуатационные требования:

- Необходимость обучения персонала
- Требования к технической поддержке
- Регламенты обновления системы

## 1.6. Взаимодействие с другими программами

Эффективная работа подсистемы «Работа с пациентами» возможна только при ее тесной интеграции с другими компонентами информационной системы поликлиники и внешними сервисами.

### 1.6.1. Внутренняя интеграция

#### С модулем расписания:

- Получение данных о доступных временных слотах
- Передача информации о запланированных приемах
- Синхронизация изменений в графике работы

#### С лабораторной системой:

- Формирование электронных направлений
- Получение результатов исследований
- Контроль выполнения назначений

#### С аптечным модулем:

- Проверка наличия лекарственных средств
- Формирование электронных рецептов
- Учет выданных препаратов

### 1.6.2. Внешняя интеграция

#### С государственными системами:

- Обмен с ЕГИСЗ (учетные данные, отчетность)
- Интеграция с системой ОМС (проверка полисов)
- Подключение к федеральным регистрам

#### С электронными сервисами:

- Интеграция с порталом госуслуг
- Поддержка мобильных приложений
- Возможность онлайн-записи

#### С другими ЛПУ:

- Обмен медицинской документацией
- Передача данных при направлении
- Получение информации о лечении

### 1.6.3. Технологии интеграции

#### Стандартные протоколы:

- Использование HL7/FHIR для медицинских данных
- Поддержка форматов JSON/XML
- REST API для веб-интеграции

#### Специализированные решения:

- Электронная подпись документов
- Шифрование передаваемых данных
- Механизмы гарантированной доставки

# 2. Инфологическая (концептуальная) модель базы данных

## 2.1. Выделение информационных объектов

При проектировании инфологической модели базы данных для подсистемы "Работа с пациентами" районной поликлиники было проведено комплексное исследование предметной области, в результате которого были выделены ключевые информационные объекты, полностью охватывающие все аспекты работы с пациентами.

### 2.1.1. Основные сущности системы

#### Пациент - центральная сущность системы:

- Уникальный идентификатор (ID пациента)
- Демографические данные (ФИО, дата рождения, пол)
- Контактная информация (адреса, телефоны, email)
- Документальные данные (полис ОМС, паспорт, СНИЛС)
- История изменений (аудит изменений персональных данных)

#### Медицинская карта - электронный аналог традиционной карты:

- Уникальный номер карты
- Даты (открытия, последнего обновления)
- Статус (активная, архивная, временно заблокированная)
- Прикрепление (участок, лечащий врач)

#### Обращение - информация о каждом визите:

- Идентификатор обращения
- Временные метки (дата/время создания, изменения)
- Тип обращения (первичное, повторное, профилактическое)
- Срочность (экстренное, неотложное, плановое)

### 2.1.2. Вспомогательные сущности

#### Врач - информация о медицинских специалистах:

- Личные данные (ФИО, контакты)
- Профессиональные данные (специализация, категория)
- Рабочие параметры (график, кабинет, лицензия)

#### Диагноз - сведения о заболеваниях:

- Классификация (код МКБ-10, наименование)
- Характеристики (тип, стадия, течение)
- Временные параметры (дата постановки, снятия)

#### Назначение - лечебные мероприятия:

- Тип назначения (медикаментозное, процедурное)
- Параметры выполнения (дозировка, режим)
- Период действия (даты назначения/отмены)

#### Расписание - учет приемов:

- Временные слоты (дата/время начала/окончания)
- Статусы (свободен, занят, отменен)
- Ресурсы (кабинет, оборудование)

### 2.1.3. Дополнительные сущности

#### Участок - территориальное деление:

- Номер участка
- Территория обслуживания
- Ответственный врач

#### Льготы - специальные категории пациентов:

- Тип льготы (федеральная, региональная)
- Документы-основания
- Срок действия

#### Прививки - вакцинация пациентов:

- Тип вакцины
- Дата проведения
- Реакция организма

## 2.2. Определение атрибутов объектов

Каждый информационный объект характеризуется комплексом атрибутов, обеспечивающих полноценное функционирование системы.

### 2.2.1. Детализация атрибутов основных сущностей

#### Пациент:

##### Идентификационные данные:

- `patient_id` (INT, PRIMARY KEY)
- `last_name` (VARCHAR(50), NOT NULL)
- `first_name` (VARCHAR(50), NOT NULL)
- `middle_name` (VARCHAR(50))
- `birth_date` (DATE, NOT NULL)
- `gender` (CHAR(1), NOT NULL)

##### Контактные данные:

- `reg_address` (TEXT, NOT NULL)
- `fact_address` (TEXT)
- `phone` (VARCHAR(20), NOT NULL)
- `email` (VARCHAR(100))
- `emergency_contact` (JSON)

##### Документальные данные:

- `oms_number` (VARCHAR(20), NOT NULL)
- `oms_company` (VARCHAR(100), NOT NULL)
- `oms_expiry` (DATE, NOT NULL)
- `passport_data` (JSON)
- `snils` (VARCHAR(14))

#### Медицинская карта:

- `card_id` (INT, PRIMARY KEY)
- `patient_id` (INT, FOREIGN KEY, UNIQUE)
- `open_date` (DATE, NOT NULL)
- `last_update` (TIMESTAMP)
- `status` (ENUM('active','archived','blocked'))
- `district_id` (INT, FOREIGN KEY)
- `attending_doctor` (INT, FOREIGN KEY)

### 2.2.2. Детализация атрибутов вспомогательных сущностей

#### Врач:

- `doctor_id` (INT, PRIMARY KEY)
- `last_name` (VARCHAR(50), NOT NULL)
- `first_name` (VARCHAR(50), NOT NULL)
- `middle_name` (VARCHAR(50))
- `specialization` (VARCHAR(100), NOT NULL)
- `category` (ENUM('none','second','first','highest'))
- `license_number` (VARCHAR(50))
- `room_number` (VARCHAR(10))
- `schedule` (JSON)

#### Диагноз:

- `diagnosis_id` (INT, PRIMARY KEY)
- `visit_id` (INT, FOREIGN KEY)
- `icd10_code` (VARCHAR(10), NOT NULL)
- `diagnosis_name` (VARCHAR(255), NOT NULL)
- `diagnosis_date` (DATE, NOT NULL)
- `diagnosis_type` (ENUM('main','complication','concomitant'))
- `stage` (VARCHAR(50))
- `character` (VARCHAR(50))

### 2.2.3. Специальные атрибуты

#### Составные атрибуты:

- Адрес (страна, регион, город, улица, дом, квартира)
- Паспортные данные (серия, номер, кем выдан, когда выдан)
- Временные интервалы (начало, окончание, продолжительность)

#### Производные атрибуты:

- Возраст пациента (вычисляется из даты рождения)
- Стаж врача (вычисляется из даты начала работы)
- Длительность заболевания (вычисляется из дат постановки/снятия диагноза)

#### Многозначные атрибуты:

- Телефоны пациента (может быть несколько)
- Специализации врача (возможны несколько)
- Аллергии пациента (перечень веществ)

## 2.3. Определение отношений и мощности отношений между объектами

Система отношений между объектами обеспечивает целостность данных и логику работы приложения.

### 2.3.1. Основные связи системы
#### Пациент ↔ Медицинская карта:

- **Тип:** композиция (сильная агрегация)
- **Мощность:** 1:1 (один к одному)
- **Обязательность:** обязательная с обеих сторон
- **Атрибуты связи:** дата создания связи

#### Пациент ↔ Обращение:

- **Тип:** ассоциация
- **Мощность:** 1:M (один ко многим)
- **Обязательность:** обязательная со стороны пациента
- **Атрибуты связи:** причина обращения

### 2.3.2. Клинические связи

#### Обращение ↔ Диагноз:

- **Тип:** агрегация
- **Мощность:** 1:M
- **Обязательность:** обязательная со стороны обращения
- **Атрибуты связи:** степень подтверждения диагноза

#### Обращение ↔ Назначение:

- **Тип:** агрегация
- **Мощность:** 1:M
- **Обязательность:** необязательная
- **Атрибуты связи:** приоритет назначения

### 2.3.3. Организационные связи

#### Врач ↔ Расписание:

- **Тип:** ассоциация
- **Мощность:** 1:M
- **Обязательность:** обязательная со стороны врача
- **Атрибуты связи:** тип приема (плановый, внеплановый)

#### Участок ↔ Пациент:

- **Тип:** ассоциация
- **Мощность:** 1:M
- **Обязательность:** обязательная со стороны участка
- **Атрибуты связи:** дата прикрепления

### 2.3.4. Специальные связи

#### Врач ↔ Диагноз:

- **Тип:** ассоциация
- **Мощность:** 1:M
- **Обязательность:** обязательная со стороны врача
- **Атрибуты связи:** уверенность в диагнозе

#### Пациент ↔ Прививки:

- **Тип:** агрегация
- **Мощность:** 1:M
- **Обязательность:** необязательная
- **Атрибуты связи:** реакция на вакцинацию

## 2.4. Построение концептуальной модели

Концептуальная модель представляет собой ER-диаграмму, отражающую все сущности, их атрибуты и взаимосвязи.

### 2.4.1. Принципы построения модели

#### Нормализация данных:

- Соответствие 3НФ (Третьей нормальной форме)
- Минимизация избыточности данных
- Обеспечение целостности данных

#### Гибкость модели:

- Возможность расширения без изменения структуры
- Поддержка историчности данных
- Адаптивность к изменениям требований

### 2.4.2. Компоненты ER-диаграммы

#### Сущности:

- Прямоугольники с названием сущности
- Внутри - список атрибутов с указанием PK (первичных ключей)

#### Связи:

- Ромбы с названием связи
- Линии с указанием мощности связи (1:1, 1:M, M:N)
- Обозначение обязательности связи

#### Атрибуты связей:

- Овалы, присоединенные к линиям связи
- Специальные обозначения для составных атрибутов

### 2.4.3. Описание ключевых элементов диаграммы

#### Центральный блок "Пациент":

- Связь с медицинской картой (1:1, обязательная)
- Связь с обращениями (1:M, обязательная)
- Связь с участком (M:1, обязательная)

#### Блок "Клинические данные":

- Цепочка Обращение → Диагноз → Назначение
- Связи с врачами и процедурами
- Учет результатов лечения

#### Блок "Организация работы":

- Расписание врачей
- Учет кабинетов и оборудования
- Управление очередями

### 2.4.4. Особенности реализации

#### Обработка временных данных:

- Ведение истории изменений
- Учет актуальных/архивных данных
- Поддержка временных ограничений

#### Безопасность данных:

- Разграничение доступа
- Шифрование конфиденциальных данных
- Ведение журналов изменений

#### Производительность:

- Оптимизация ключевых запросов
- Индексация часто используемых полей
- Кэширование редко изменяемых данных

# 3. Логическая структура базы данных

## 3.1. Преобразование концептуальной модели в логическую

Процесс трансформации концептуальной ER-модели в логическую схему реляционной базы данных представляет собой сложный многоэтапный процесс, требующий тщательного анализа и учета всех особенностей предметной области. Рассмотрим этот процесс детально.

### 3.1.1. Основные принципы преобразования

#### Принцип соответствия сущностей и таблиц:

- Каждая сущность концептуальной модели отображается на отдельную таблицу в логической модели.
- Сложные сущности с иерархией могут требовать нескольких связанных таблиц.
- Абстрактные сущности реализуются через механизм наследования таблиц.

#### Принцип сохранения семантики:

- Все бизнес-правила и ограничения концептуальной модели должны быть сохранены.
- Семантика связей между сущностями точно передается через систему внешних ключей.
- Обеспечивается полное соответствие логической модели исходным требованиям.

#### Принцип оптимальной производительности:

- Учитываются предполагаемые нагрузки и частые запросы.
- Производится предварительная оптимизация структуры.
- Закладываются возможности для масштабирования.

### 3.1.2. Детализация процесса преобразования

#### Для сущности "Пациент":

- Преобразуется в таблицу `PATIENTS` со всеми атрибутами.
- Составные атрибуты (адрес, паспортные данные) разбиваются на отдельные поля.
- Многозначные атрибуты (телефоны, контакты) выносятся в отдельные таблицы.
- Добавляются служебные поля для аудита изменений.

#### Для сущности "Медицинская карта":

- Создается таблица `MEDICAL_CARDS` с обязательной связью 1:1 с `PATIENTS`.
- История изменений карты выносится в отдельную таблицу `CARD_HISTORY`.
- Специальные медицинские показатели (группа крови, аллергии) оформляются отдельно.

#### Для связи "Пациент-Обращение":

- Реализуется через внешний ключ `patient_id` в таблице `VISITS`.
- Добавляются индексы для ускорения поиска всех обращений пациента.
- Учитывается необходимость каскадного обновления/удаления.

### 3.1.3. Обработка сложных случаев

#### Наследование ("Врач является Сотрудником"):

- **Вариант 1:** Единая таблица с флагом типа.
- **Вариант 2:** Основная таблица сотрудников + таблица врачей.
- **Вариант 3:** Полноценная иерархия с таблицей-родителем.

#### Многозначные атрибуты ("Специализации врача"):

- Создается таблица `SPECIALIZATIONS`.
- Создается связующая таблица `DOCTOR_SPECIALIZATIONS`.
- Добавляются соответствующие внешние ключи.

#### Временные данные ("История изменения диагноза"):

- Основная таблица текущих диагнозов.
- Таблица-журнал `DIAGNOSIS_HISTORY`.
- Механизм триггеров для автоматического журналирования.

## 3.2. Полная спецификация таблиц базы данных

Логическая структура базы данных включает комплекс взаимосвязанных таблиц, каждая из которых имеет строго определенную структуру и назначение.

### 3.2.1. Основные таблицы системы

#### Таблица `PATIENTS` (Пациенты):

* `patient_id` - INT, PRIMARY KEY, AUTO_INCREMENT
  - Уникальный идентификатор пациента
  - Автоматически генерируемое значение
  - Используется как внешний ключ в связанных таблицах

* `last_name` - VARCHAR(50), NOT NULL
  - Фамилия пациента
  - Обязательное поле
  - Индексируется для поиска

* `first_name` - VARCHAR(50), NOT NULL
  - Имя пациента
  - Обязательное поле
  - Совместно с фамилией образует полное имя

* `middle_name` - VARCHAR(50)
  - Отчество пациента
  - Необязательное поле
  - Может отсутствовать для иностранных граждан

* `birth_date` - DATE, NOT NULL
  - Дата рождения
  - Используется для расчета возраста
  - Проверка на допустимый диапазон дат

* `gender` - ENUM('M','F','U'), NOT NULL
  - Пол пациента (Мужской/Женский/Не указан)
  - Используется для медицинской статистики
  - Учитывается при назначении обследований

Таблица MEDICAL_CARDS (Медицинские карты):

* `card_id` - INT, PRIMARY KEY, AUTO_INCREMENT
  - Уникальный идентификатор карты
  - Суррогатный ключ
  - Не содержит семантической нагрузки

* `patient_id` - INT, FOREIGN KEY, UNIQUE
  - Ссылка на пациента
  - Ограничение UNIQUE обеспечивает связь 1:1
  - Каскадное обновление при изменении patient_id

* `open_date` - DATE, NOT NULL
  - Дата открытия карты
  - Не может быть в будущем
  - Сравнивается с датой рождения пациента

* `status` - ENUM('active','archived','blocked'), DEFAULT 'active'
  - Текущий статус карты
  - Активная - для текущих пациентов
  - Архивная - для давно не обращавшихся
  - Заблокированная - для особых случаев

3.2.2. Клинические таблицы
Таблица VISITS (Обращения):

* `visit_id` - BIGINT, PRIMARY KEY, AUTO_INCREMENT
  - Уникальный идентификатор обращения
  - BIGINT для учета большого количества записей
  - Автоматическая генерация значений

* `patient_id` - INT, FOREIGN KEY, NOT NULL
  - Ссылка на пациента
  - Индекс для быстрого поиска всех обращений пациента
  - Ограничение NOT NULL - каждое обращение должно быть привязано к пациенту

* `doctor_id` - INT, FOREIGN KEY, NOT NULL
  - Ссылка на врача
  - Индекс для анализа нагрузки врачей
  - Ограничение NOT NULL - каждый прием ведет конкретный врач

* `visit_date` - DATETIME, NOT NULL
  - Дата и время приема
  - Индекс для поиска по датам
  - Проверка на допустимое время работы поликлиники

Таблица DIAGNOSES (Диагнозы):

* `diagnosis_id` - BIGINT, PRIMARY KEY, AUTO_INCREMENT
  - Уникальный идентификатор диагноза
  - BIGINT для учета длительной истории болезней
  - Автоматическая генерация значений

* `visit_id` - BIGINT, FOREIGN KEY, NOT NULL
  - Ссылка на обращение
  - Индекс для быстрого доступа
  - Каскадное удаление при удалении обращения

* `icd10_code` - VARCHAR(10), NOT NULL
  - Код по международной классификации болезней
  - Проверка на соответствие формату МКБ-10
  - Связь со справочником кодов МКБ

## 3.3. Система связей между таблицами

Логическая модель включает сложную систему связей, обеспечивающую целостность данных и выполнение бизнес-правил поликлиники.

### 3.3.1. Основные связи системы

#### Связь `PATIENTS` ↔ `MEDICAL_CARDS`:

- **Тип:** один-к-одному (1:1)
- **Реализация:** через `patient_id` с ограничением UNIQUE
- **Ограничения:**
  - `ON DELETE CASCADE` - при удалении пациента удаляется его карта
  - `ON UPDATE CASCADE` - при изменении `patient_id` автоматически обновляется ссылка
- **Семантика:** каждый пациент имеет ровно одну медицинскую карту

#### Связь `PATIENTS` ↔ `VISITS`:

- **Тип:** один-ко-многим (1:M)
- **Реализация:** через `patient_id` в таблице `VISITS`
- **Ограничения:**
  - `ON DELETE RESTRICT` - нельзя удалить пациента с существующими обращениями
  - `ON UPDATE CASCADE` - изменение `patient_id` автоматически обновляет ссылки
- **Индексы:** составной индекс по `(patient_id, visit_date)` для быстрого доступа к истории обращений

### 3.3.2. Клинические связи

#### Связь `VISITS` ↔ `DIAGNOSES`:

- **Тип:** один-ко-многим (1:M)
- **Реализация:** через `visit_id` в таблице `DIAGNOSES`
- **Ограничения:**
  - `ON DELETE CASCADE` - при удалении обращения удаляются все связанные диагнозы
  - `ON UPDATE CASCADE` - автоматическое обновление ссылок
- **Особенности:** дополнительный индекс по `icd10_code` для медицинской статистики

#### Связь `VISITS` ↔ `PRESCRIPTIONS`:

- **Тип:** один-ко-многим (1:M)
- **Реализация:** через `visit_id` в таблице `PRESCRIPTIONS`
- **Ограничения:**
  - `ON DELETE RESTRICT` - нельзя удалить обращение с существующими назначениями
  - `ON UPDATE CASCADE` - автоматическое обновление ссылок
- **Бизнес-правило:** проверка срока действия назначений

## 3.4. Нормализация и оптимизация структуры

Процесс проектирования логической структуры включал строгую нормализацию с последующей контролируемой денормализацией для повышения производительности.

### 3.4.1. Процесс нормализации

#### Первая нормальная форма (1NF):

- Все таблицы имеют первичный ключ.
- Все атрибуты атомарны.
- Адрес разбит на компоненты (страна, город, улица, дом).
- Паспортные данные разделены на серию, номер, дату выдачи.
- Отсутствуют повторяющиеся группы.
- Нет смешанных типов данных в одном поле.

#### Вторая нормальная форма (2NF):

- Все таблицы соответствуют 1NF.
- Устранены частичные зависимости.
- Данные о страховой компании вынесены в отдельную таблицу.
- Специализации врачей выделены в отдельную сущность.
- Все неключевые атрибуты зависят от всего первичного ключа.

#### Третья нормальная форма (3NF):

- Все таблицы соответствуют 2NF.
- Устранены транзитивные зависимости.
- Расчетные поля (возраст, стаж) либо вычисляются, либо кэшируются.
- Нормализованы все справочники (коды МКБ, лекарственные препараты).
- Нет избыточности в хранении данных.

### 3.4.2. Контролируемая денормализация

#### Обоснованные исключения:

- Хранение полного имени врача в таблице `VISITS` для ускорения отчетов.
- Кэширование количества обращений пациента в таблице `PATIENTS`.
- Хранение производных данных (среднее время приема) для аналитики.

#### Оптимизационные решения:

- Вертикальное партиционирование редко используемых полей.
- Горизонтальное партиционирование по временным периодам.
- Создание материализованных представлений для сложных запросов.


# 4. Физическая структура базы данных

## 4.1. Выбор системы управления базами данных (СУБД)

### 4.1.1. Критерии выбора СУБД для поликлиники

#### Требования к производительности:

- Поддержка высоких нагрузок в часы пик (утренние часы приема).
- Быстрое выполнение сложных запросов к истории болезней.
- Эффективная работа с составными индексами.

#### Требования к надежности:

- Механизмы автоматического восстановления после сбоев.
- Поддержка горячего резервирования.
- Транзакционная целостность данных.

#### Требования к безопасности:

- Шифрование данных на уровне полей.
- Подробная система разграничения прав доступа.
- Аудит всех операций с данными.

#### Специфические медицинские требования:

- Поддержка временных рядов для медицинских показателей.
- Возможность хранения неструктурированных данных (снимки, сканы).
- Специальные типы данных для медицинской информации.

### 4.1.2. Сравнительный анализ СУБД

#### PostgreSQL:

- **Преимущества:**
  - Полноценная объектно-реляционная модель.
  - Поддержка JSON и XML для медицинских документов.
  - Расширения для временных рядов и геоданных.
- **Недостатки:**
  - Требовательность к ресурсам.
  - Сложность настройки для высоких нагрузок.

#### Microsoft SQL Server:

- **Преимущества:**
  - Интеграция с другими продуктами Microsoft.
  - Отличные инструменты анализа данных.
  - Поддержка сложных вычислений.
- **Недостатки:**
  - Высокая стоимость лицензий.
  - Привязка к экосистеме Microsoft.

#### MySQL:

- **Преимущества:**
  - Высокая производительность простых запросов.
  - Низкие требования к ресурсам.
  - Широкая распространенность.
- **Недостатки:**
  - Ограниченная функциональность.
  - Проблемы с масштабированием.

#### Oracle Database:

- **Преимущества:**
  - Лидер по возможностям и надежности.
  - Встроенные механизмы шифрования.
  - Поддержка распределенных баз данных.
- **Недостатки:**
  - Экстремально высокая стоимость.
  - Сложность администрирования.

### 4.1.3. Обоснование выбора PostgreSQL

Для системы районной поликлиники выбран PostgreSQL как оптимальный баланс между:

- Бесплатностью и открытостью кода.
- Богатой функциональностью.
- Возможностями масштабирования.
- Поддержкой медицинских стандартов.
- Надежностью и безопасностью данных.

## 4.2. Физическая реализация таблиц

### 4.2.1. DDL-скрипты создания таблиц

#### Таблица `PATIENTS`:

CREATE TABLE patients (
    patient_id SERIAL PRIMARY KEY,
    last_name VARCHAR(50) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    middle_name VARCHAR(50),
    birth_date DATE NOT NULL CHECK (birth_date > '1900-01-01'),
    gender CHAR(1) NOT NULL CHECK (gender IN ('M','F')),
    reg_address JSONB NOT NULL,
    fact_address JSONB,
    phone VARCHAR(20) NOT NULL,
    email VARCHAR(100) CHECK (email LIKE '%@%.%'),
    oms_number VARCHAR(20) NOT NULL UNIQUE,
    oms_company VARCHAR(100) NOT NULL,
    oms_expiry_date DATE NOT NULL,
    passport_series VARCHAR(4),
    passport_number VARCHAR(6),
    passport_issued_by TEXT,
    passport_issue_date DATE,
    snils VARCHAR(14) UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    visits_count INTEGER DEFAULT 0
);

CREATE INDEX idx_patients_name ON patients (last_name, first_name);
CREATE INDEX idx_patients_oms ON patients (oms_number);
CREATE INDEX idx_patients_birth_date ON patients (birth_date);

Таблица MEDICAL_CARDS:

CREATE TABLE medical_cards (
    card_id SERIAL PRIMARY KEY,
    patient_id INTEGER UNIQUE NOT NULL REFERENCES patients(patient_id) ON DELETE CASCADE,
    open_date DATE NOT NULL CHECK (open_date >= '2000-01-01'),
    close_date DATE CHECK (close_date IS NULL OR close_date >= open_date),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE','ARCHIVED','BLOCKED')),
    district_id INTEGER REFERENCES districts(district_id),
    attending_doctor_id INTEGER REFERENCES doctors(doctor_id),
    blood_type VARCHAR(2) CHECK (blood_type IN ('I','II','III','IV','UNKNOWN')),
    rh_factor VARCHAR(1) CHECK (rh_factor IN ('+','-','UNKNOWN')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_dates CHECK (close_date IS NULL OR close_date >= open_date)
);

CREATE INDEX idx_medical_cards_patient ON medical_cards(patient_id);
CREATE INDEX idx_medical_cards_status ON medical_cards(status);
CREATE INDEX idx_medical_cards_doctor ON medical_cards(attending_doctor_id);

## 4.3. Индексы и оптимизация запросов

### 4.3.1. Стратегия индексирования

#### Базовые индексы:

- Все первичные ключи (автоматически индексируются).
- Все внешние ключи (для ускорения JOIN-операций).
- Уникальные поля (OMS, СНИЛС, паспорт).

#### Составные индексы:

- Для частых запросов по ФИО и дате рождения.
- Для поиска пациентов по участку и врачу.
- Для анализа обращений по датам и врачам.

#### Специальные индексы:

- GIN-индексы для JSON-данных (адреса).
- Частичные индексы для активных записей.
- Индексы по выражениям (например, возраст).

### 4.3.2. Примеры создания оптимизированных индексов

Для быстрого поиска пациентов:

CREATE INDEX idx_patient_search ON patients 
USING gin ((last_name || ' ' || first_name || ' ' || COALESCE(middle_name, '')) gin_trgm_ops);

Для временных запросов:

CREATE INDEX idx_visits_date_doctor ON visits (visit_date, doctor_id) 
WHERE status = 'COMPLETED';

Для медицинской аналитики:

CREATE INDEX idx_diagnoses_icd_date ON diagnoses (icd10_code, diagnosis_date) 
INCLUDE (patient_id);

## 4.4. Хранимые процедуры и триггеры

### 4.4.1. Критические хранимые процедуры

#### Регистрация нового пациента:

CREATE OR REPLACE FUNCTION register_patient(
    p_last_name VARCHAR,
    p_first_name VARCHAR,
    p_birth_date DATE,
    p_gender CHAR,
    p_oms_number VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    new_patient_id INTEGER;
BEGIN
    -- Проверка уникальности ОМС
    IF EXISTS (SELECT 1 FROM patients WHERE oms_number = p_oms_number) THEN
        RAISE EXCEPTION 'Пациент с таким номером ОМС уже зарегистрирован';
    END IF;
    
    -- Вставка нового пациента
    INSERT INTO patients (
        last_name, first_name, birth_date, gender, oms_number
    ) VALUES (
        p_last_name, p_first_name, p_birth_date, p_gender, p_oms_number
    ) RETURNING patient_id INTO new_patient_id;
    
    -- Создание медицинской карты
    INSERT INTO medical_cards (patient_id, open_date)
    VALUES (new_patient_id, CURRENT_DATE);
    
    RETURN new_patient_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

Обновление счетчика обращений:

CREATE OR REPLACE FUNCTION update_visits_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE patients 
        SET visits_count = visits_count + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE patient_id = NEW.patient_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE patients 
        SET visits_count = visits_count - 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE patient_id = OLD.patient_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_visits_count
AFTER INSERT OR DELETE ON visits
FOR EACH ROW EXECUTE FUNCTION update_visits_count();

## 4.5. Разграничение прав доступа

### 4.5.1. Ролевая модель доступа

#### Администратор БД (db_admin):
- Полный доступ ко всем объектам.
- Право создавать и изменять схемы.
- Управление пользователями и ролями.

#### Регистратор (registrar):
- Чтение/запись таблиц пациентов и расписания.
- Ограниченный доступ к медицинским данным.
- Нет доступа к финансовой информации.

#### Врач (doctor):
- Полный доступ к медицинским картам своих пациентов.
- Ограниченный доступ к другим пациентам.
- Возможность создавать диагнозы и назначения.

#### Медсестра (nurse):
- Просмотр назначений.
- Ввод результатов процедур.
- Нет доступа к редактированию диагнозов.

### 4.5.2. Примеры назначения прав

-- Создание роли врача
CREATE ROLE doctor_role NOLOGIN;
GRANT CONNECT ON DATABASE polyclinic TO doctor_role;

-- Назначение прав на таблицы
GRANT SELECT, INSERT, UPDATE ON medical_cards TO doctor_role;
GRANT SELECT, INSERT, UPDATE ON visits TO doctor_role;
GRANT SELECT, INSERT, UPDATE ON diagnoses TO doctor_role;
GRANT SELECT ON patients TO doctor_role;

-- Создание пользователя
CREATE USER dr_ivanov WITH PASSWORD 'secure123';
GRANT doctor_role TO dr_ivanov;

-- Ограничение доступа только к своим пациентам
CREATE POLICY doctor_patients_policy ON medical_cards
FOR ALL TO doctor_role
USING (attending_doctor_id = current_user_id());


# 5. Реализация проекта в среде PostgreSQL

## 5.1. Создание таблиц

### 5.1.1. Разработка DDL-скриптов

Для реализации физической модели базы данных поликлиники в PostgreSQL разработаны следующие скрипты создания таблиц:

-- Создание схемы базы данных
CREATE SCHEMA polyclinic;
SET search_path TO polyclinic;

-- Таблица участков
CREATE TABLE districts (
    district_id SERIAL PRIMARY KEY,
    district_number VARCHAR(10) NOT NULL UNIQUE,
    territory_description TEXT NOT NULL,
    head_doctor_id INT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Таблица сотрудников
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    last_name VARCHAR(50) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    middle_name VARCHAR(50),
    position VARCHAR(100) NOT NULL,
    hire_date DATE NOT NULL,
    dismissal_date DATE,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE'
);

-- Таблица врачей (наследуется от сотрудников)
CREATE TABLE doctors (
    doctor_id INT PRIMARY KEY REFERENCES employees(employee_id),
    specialization VARCHAR(100) NOT NULL,
    qualification VARCHAR(50) NOT NULL,
    license_number VARCHAR(50) UNIQUE,
    room_number VARCHAR(10) NOT NULL,
    schedule JSONB NOT NULL
) INHERITS (employees);

-- Таблица пациентов
CREATE TABLE patients (
    patient_id SERIAL PRIMARY KEY,
    last_name VARCHAR(50) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    middle_name VARCHAR(50),
    birth_date DATE NOT NULL CHECK (birth_date > '1900-01-01'),
    gender CHAR(1) NOT NULL CHECK (gender IN ('M','F')),
    reg_address JSONB NOT NULL,
    fact_address JSONB,
    phone VARCHAR(20) NOT NULL,
    email VARCHAR(100) CHECK (email LIKE '%@%.%'),
    oms_number VARCHAR(20) NOT NULL UNIQUE,
    oms_company VARCHAR(100) NOT NULL,
    oms_expiry_date DATE NOT NULL,
    passport_data JSONB,
    snils VARCHAR(14) UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

5.1.2. Создание связей между таблицами

-- Добавление внешних ключей
ALTER TABLE districts 
ADD CONSTRAINT fk_head_doctor 
FOREIGN KEY (head_doctor_id) REFERENCES doctors(doctor_id);

-- Таблица медицинских карт
CREATE TABLE medical_cards (
    card_id SERIAL PRIMARY KEY,
    patient_id INT UNIQUE NOT NULL REFERENCES patients(patient_id) 
        ON DELETE CASCADE ON UPDATE CASCADE,
    open_date DATE NOT NULL DEFAULT CURRENT_DATE,
    close_date DATE,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' 
        CHECK (status IN ('ACTIVE','ARCHIVED','BLOCKED')),
    district_id INT REFERENCES districts(district_id),
    attending_doctor_id INT REFERENCES doctors(doctor_id),
    blood_type VARCHAR(2) CHECK (blood_type IN ('I','II','III','IV','UNKNOWN')),
    rh_factor VARCHAR(1) CHECK (rh_factor IN ('+','-','UNKNOWN')),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT chk_dates CHECK (close_date IS NULL OR close_date >= open_date)

5.2. Создание запросов
5.2.1. Типовые SQL-запросы системы
1. Поиск пациентов по ФИО и дате рождения:

CREATE OR REPLACE FUNCTION search_patients(
    p_last_name VARCHAR DEFAULT NULL,
    p_first_name VARCHAR DEFAULT NULL,
    p_birth_date DATE DEFAULT NULL
) RETURNS SETOF patients AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM patients
    WHERE (p_last_name IS NULL OR last_name ILIKE p_last_name || '%')
      AND (p_first_name IS NULL OR first_name ILIKE p_first_name || '%')
      AND (p_birth_date IS NULL OR birth_date = p_birth_date)
    ORDER BY last_name, first_name
    LIMIT 100;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

2. Получение полной истории обращений пациента:

CREATE OR REPLACE FUNCTION get_patient_history(
    p_patient_id INT
) RETURNS TABLE (
    visit_date TIMESTAMPTZ,
    doctor_name TEXT,
    specialization VARCHAR(100),
    complaints TEXT,
    diagnosis TEXT,
    prescriptions TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        v.visit_date,
        d.last_name || ' ' || d.first_name || ' ' || COALESCE(d.middle_name, '') AS doctor_name,
        d.specialization,
        v.complaints,
        string_agg(dg.icd10_code || ' - ' || dg.diagnosis_name, ', ') AS diagnosis,
        string_agg(p.prescription_text, '; ') AS prescriptions
    FROM visits v
    JOIN doctors d ON v.doctor_id = d.doctor_id
    LEFT JOIN diagnoses dg ON v.visit_id = dg.visit_id
    LEFT JOIN prescriptions p ON v.visit_id = p.visit_id
    WHERE v.patient_id = p_patient_id
    GROUP BY v.visit_id, v.visit_date, d.last_name, d.first_name, d.middle_name, d.specialization, v.complaints
    ORDER BY v.visit_date DESC;
END;
$$ LANGUAGE plpgsql;

# 5.3. Разработка интерфейса

## 5.3.1. Архитектура клиентского приложения

**Frontend:**

- Веб-интерфейс на React.js
- Мобильное приложение на React Native
- Административная панель на Vue.js

**Backend:**

- RESTful API на Node.js Express
- WebSocket для реальных обновлений
- Интеграция с PostgreSQL через pg-promise

## 5.3.2. Пример API-эндпоинтов

1. Эндпоинт регистрации пациента:

router.post('/api/patients', authenticate('registrar'), async (req, res) => {
  try {
    const { lastName, firstName, birthDate, omsNumber } = req.body;
    
    const patient = await db.query(
      'SELECT * FROM register_patient($1, $2, $3, $4)',
      [lastName, firstName, birthDate, omsNumber]
    );
    
    res.status(201).json(patient);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

2. Эндпоинт поиска пациентов:

router.get('/api/patients/search', authenticate(['doctor','registrar']), async (req, res) => {
  try {
    const { lastName, firstName, birthDate, omsNumber } = req.query;
    
    const patients = await db.query(
      'SELECT * FROM search_patients($1, $2, $3, $4)',
      [lastName, firstName, birthDate, omsNumber]
    );
    
    res.json(patients);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

5.4. Назначение прав доступа
5.4.1. Ролевая модель безопасности

-- Создание ролей
CREATE ROLE polyclinic_admin WITH NOLOGIN;
CREATE ROLE polyclinic_doctor WITH NOLOGIN;
CREATE ROLE polyclinic_registrar WITH NOLOGIN;
CREATE ROLE polyclinic_nurse WITH NOLOGIN;

-- Назначение прав администратору
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA polyclinic TO polyclinic_admin;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA polyclinic TO polyclinic_admin;
GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA polyclinic TO polyclinic_admin;

-- Назначение прав врачам
GRANT SELECT, INSERT, UPDATE ON 
    patients, medical_cards, visits, diagnoses, prescriptions 
TO polyclinic_doctor;

GRANT SELECT ON 
    doctors, employees, districts 
TO polyclinic_doctor;

-- Политика доступа к данным пациентов
CREATE POLICY doctor_patient_policy ON medical_cards
    FOR ALL TO polyclinic_doctor
    USING (attending_doctor_id = current_user_id());

5.5. Создание индексов
5.5.1. Оптимизация производительности

-- Индексы для таблицы пациентов
CREATE INDEX idx_patients_name_trgm ON patients 
    USING gin (last_name gin_trgm_ops, first_name gin_trgm_ops);
    
CREATE INDEX idx_patients_oms ON patients (oms_number);
CREATE INDEX idx_patients_birth_date ON patients (birth_date);
CREATE INDEX idx_patients_phone ON patients (phone);

-- Индексы для таблицы обращений
CREATE INDEX idx_visits_patient_date ON visits (patient_id, visit_date DESC);
CREATE INDEX idx_visits_doctor_date ON visits (doctor_id, visit_date DESC);
CREATE INDEX idx_visits_status_date ON visits (status, visit_date);

-- Частичный индекс для активных записей
CREATE INDEX idx_medical_cards_active ON medical_cards (patient_id)
    WHERE status = 'ACTIVE';

5.6. Разработка стратегии резервного копирования
5.6.1. Комплексная стратегия бэкапа

1. Ежедневные полные бэкапы:

#!/bin/bash
DATE=$(date +%Y-%m-%d)
pg_dump -Fc -U backup_user -d polyclinic -f /backups/full_$DATE.dump

2. Почасовые WAL-архивы:

# postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'cp %p /backups/wal/%f'

3. Репликация в standby-сервер:

# postgresql.conf
hot_standby = on
primary_conninfo = 'host=primary.polyclinic.local port=5432 user=replica password=secret'

4. Скрипт восстановления:

#!/bin/bash
pg_restore -U admin -d polyclinic -Fc /backups/full_2023-11-15.dump

5. Мониторинг целостности бэкапов:

-- Проверка последнего бэкапа
SELECT pg_is_in_backup(), 
       pg_backup_start_time(),
       pg_is_wal_replay_paused();
